import blenderproc as bproc
import bpy
import os
import imageio
import numpy as np
import random
from PIL import Image, ImageDraw

# --- Setup paths ---
wound_dir = "/Users/Mira/Projects/Git Repository/HOPE/output/wound_textures_v2"
out_dir = "/Users/Mira/Projects/Git Repository/HOPE/output/human_wounds/v4"
os.makedirs(out_dir, exist_ok=True)

# --- make circle with transparency ---
def make_red_circle(path, size=512, radius_frac=0.3):
    img = Image.new("RGBA", (size, size), (0, 0, 0, 0))  # transparent background
    draw = ImageDraw.Draw(img)
    radius = int(size * radius_frac)
    center = size // 2
    draw.ellipse(
        [center - radius, center - radius, center + radius, center + radius],
        fill=(255, 0, 0, 255)
    )
    img.save(path)

# --- Init BlenderProc ---
bproc.init()
# --- Load cameras ---
bproc.camera.set_resolution(512, 512)

def render_one_pose(cam_pose, out_path):
    # Clear previous camera poses
    bproc.camera.add_camera_pose(cam_pose)
    data = bproc.renderer.render()
    rgb = data["colors"][0]
    imageio.imwrite(out_path, rgb)

# --- Init random ---
rng = np.random.default_rng()


# --- Make a simple plane (the "skin") ---
body = bproc.loader.load_obj("HOPE/bodies/human_boy_v1.obj")[0]
body.set_location([3, 0, 0])   # center at origin
body.set_scale([0.5, 0.5, 0.5])  # adjust scaling (try smaller or larger if not visible)
body.set_rotation_euler([0, 0, np.pi/2]) # Rotate body 90 degrees around Z-axis


# --- Load light ---
light = bproc.types.Light()
light.set_type("AREA")
light.set_location([0, 0, 9])
light.set_energy(3000)

# radius_frac=rng.uniform(0.1, 0.3)
# --- Make circles ---
for i in range(5):
    make_red_circle(os.path.join(wound_dir, f"wound_{i:04d}.png"), 
                    radius_frac=0.3)

# --- Collect all PNG wound images ---
wound_files = [f for f in os.listdir(wound_dir) if f.endswith(".png")]
print("Found wound textures:", wound_files)

'''
# Approach 1: Create a composite material for the body with wound overlay
def create_body_material_with_wound(body_obj, wound_texture_path, wound_location, wound_scale=0.1):
    """Create a material that combines the body texture with a wound decal"""
    
    # Create new material
    mat = bproc.material.create(f"BodyWithWound")
    
    # Get material nodes and links
    nodes = mat.get_nodes()
    links = mat.get_links()
    
    # Remove default principled BSDF to start fresh
    principled = nodes.get("Principled BSDF")
    material_output = nodes.get("Material Output")
    
    # Add texture coordinate node for UV mapping
    tex_coord = nodes.new(type='ShaderNodeTexCoord')
    
    # Add mapping node for positioning the wound
    mapping = nodes.new(type='ShaderNodeMapping')
    mapping.inputs['Location'].default_value = wound_location  # [X, Y, Z] offset
    mapping.inputs['Scale'].default_value = [wound_scale, wound_scale, wound_scale]
    
    # Add wound texture
    wound_tex = nodes.new(type='ShaderNodeTexImage')
    wound_tex.image = bpy.data.images.load(wound_texture_path)
    wound_tex.image.alpha_mode = 'STRAIGHT'
    
    # Add base body color (or you could load a body texture here)
    body_color = nodes.new(type='ShaderNodeRGB')
    body_color.outputs[0].default_value = [0.8, 0.7, 0.6, 1.0]  # Skin tone
    
    # Add mix node to blend body color with wound
    mix_shader = nodes.new(type='ShaderNodeMix')
    mix_shader.data_type = 'RGBA'
    mix_shader.blend_type = 'MIX'
    
    # Connect nodes
    links.new(tex_coord.outputs['UV'], mapping.inputs['Vector'])
    links.new(mapping.outputs['Vector'], wound_tex.inputs['Vector'])
    
    # Mix the body color with wound texture using wound alpha
    links.new(body_color.outputs['Color'], mix_shader.inputs['Color1'])  # Base body
    links.new(wound_tex.outputs['Color'], mix_shader.inputs['Color2'])   # Wound
    links.new(wound_tex.outputs['Alpha'], mix_shader.inputs['Fac'])      # Use wound alpha as blend factor
    
    # Connect to principled BSDF
    links.new(mix_shader.outputs['Color'], principled.inputs['Base Color'])
    
    return mat
    '''

# Simple approach: Apply wound texture directly to body
def apply_wound_to_body(body_obj, wound_texture_path):
    """Apply wound texture directly to the body using BlenderProc's built-in methods"""
    
    # Create a base skin material first
    skin_mat = bproc.material.create("SkinMaterial")
    
    # Access the underlying Blender material to work with nodes
    blender_mat = skin_mat.blender_obj
    blender_mat.use_nodes = True
    nodes = blender_mat.node_tree.nodes
    links = blender_mat.node_tree.links
    
    # Clear existing nodes and start fresh
    nodes.clear()
    
    # Create essential nodes
    output_node = nodes.new(type='ShaderNodeOutputMaterial')
    principled = nodes.new(type='ShaderNodeBsdfPrincipled')
    
    # Create texture coordinate node
    tex_coord = nodes.new(type='ShaderNodeTexCoord')
    
    # Create wound texture node
    wound_tex = nodes.new(type='ShaderNodeTexImage')
    wound_tex.image = bpy.data.images.load(wound_texture_path)
    if wound_tex.image:
        wound_tex.image.alpha_mode = 'STRAIGHT'
    
    # Create a mapping node to control wound position and scale
    mapping = nodes.new(type='ShaderNodeMapping')
    # Scale the wound to be more visible (larger)
    mapping.inputs['Scale'].default_value = [0.03,0.03,0.03]  # Make wound bigger
    # Center the wound
    mapping.inputs['Location'].default_value = [0.2, 0.5, 0.0]
    
    # Create base skin color
    skin_color = nodes.new(type='ShaderNodeRGB')
    skin_color.outputs[0].default_value = [0.8, 0.7, 0.6, 1.0]  # Opaque skin tone
    
    # Create ColorRamp node to make wound more visible
    color_ramp = nodes.new(type='ShaderNodeValToRGB')
    color_ramp.color_ramp.elements[0].color = [0.35,0.22,0.15,0]  # Skin color
    color_ramp.color_ramp.elements[1].color = [0.8, 0.0, 0.0, 1.0]  # Red wound color
    
    # Connect nodes
    links.new(tex_coord.outputs['UV'], mapping.inputs['Vector'])  # Use Generated coords for better coverage
    links.new(mapping.outputs['Vector'], wound_tex.inputs['Vector'])
    links.new(wound_tex.outputs['Alpha'], color_ramp.inputs['Fac'])
    links.new(color_ramp.outputs['Color'], principled.inputs['Base Color'])
    links.new(principled.outputs['BSDF'], output_node.inputs['Surface'])
    
    # Enable transparency
    blender_mat.blend_method = 'BLEND'
    
    return skin_mat

# Store original body material to restore later
original_materials = body.get_materials()


for i, wound_file in enumerate(wound_files):
    # Clear previous camera poses
    bproc.utility.reset_keyframes()
    
    wound_path = os.path.join(wound_dir, wound_file)
    print(f"Processing wound {i}: {wound_path}")

    # Restore original materials first
    body.clear_materials()
    for mat in original_materials:
        body.add_material(mat)
    
    # Choose your approach:
    
    # Simple approach (recommended for testing):
    wound_mat = apply_wound_to_body(body, wound_path)
    if wound_mat is None:
        print(f"DEBUG: Skipping iteration {i} - material creation failed")
        continue
        
    #Clear existing materials and apply wound material
    print(f"DEBUG: Body had {len(body.get_materials())} materials before clearing")
    body.clear_materials()
    body.add_material(wound_mat)
    print(f"DEBUG: Body now has {len(body.get_materials())} materials after applying wound")
    
    # Debug: Check body properties
    print(f"DEBUG: Body location: {body.get_location()}")
    print(f"DEBUG: Body scale: {body.get_scale()}")
    print(f"DEBUG: Body rotation: {body.get_rotation_euler()}")
    
    # Debug: Check if body has UV coordinates
    body_mesh = body.get_mesh()
    if body_mesh:
        print(f"DEBUG: Body mesh has {len(body_mesh.vertices)} vertices")
        print(f"DEBUG: Body mesh has {len(body_mesh.loops)} UV loops")
    else:
        print("DEBUG: ERROR - Could not access body mesh!")
    
    print(f"DEBUG: About to render iteration {i}")
    
    # Set transparency in render settings
    bpy.context.scene.render.film_transparent = True

    # Advanced approach (for more control):
    # Random location for wound on UV space
    # wound_uv_location = [
    #     np.random.uniform(-0.5, 0.5),  # U coordinate
    #     np.random.uniform(-0.5, 0.5),  # V coordinate  
    #     0  # Z not used for UV
    # ]
    # wound_mat = create_body_material_with_wound_advanced(body, wound_path, wound_uv_location, wound_scale=0.05)
    
    # Apply the wound material to the body
    body.add_material(wound_mat)
    
    # Set transparency in render settings
    bpy.context.scene.render.film_transparent = True
    
    # Set camera pose
    pose = bproc.math.build_transformation_mat([0, 0, 9], [0, 0, 0])
    
    # Save with unique filename
    out_path = os.path.join(out_dir, f"{i:03d}.png")
    render_one_pose(pose, out_path)
    
    print("Saved:", out_path)

print("Done! All renders are in:", out_dir)